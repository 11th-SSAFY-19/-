# 5. 안정 해시 설계

**안정 해시**를 통해서 요청 또는 데이터를 서버에 균등하게 나누면서 수평적 확장을 할 수 있습니다.

### 📌 해시 키 재배치(rehash) 문제

- **서버들에 부하를 균등하게 나누는 보편적인 방법**
    
    `serverIndex = hash(key) % N (N은 서버의 개수)`
    
- 총 4대의 서버를 사용한다고 가정했을 때
위의 공식을 사용해서 주어진 각각의 키에 대해서 해시값과 서버 인덱스를 계산해보자!  

    <img width="310" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-10_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8 16 07" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/50784fad-b12a-48a0-875a-19e609f578c7">

hash(key0) % 4 = 1이면, 클라이언트는 캐시에 보관된 데이터를 가져오기 위해 서버 1에 접속해야 한다.

<img width="358" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-10_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8 16 21" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/aa255b29-9f6f-42c6-86a2-ea75b4a40cec">

이 방법은 Server Pool의 크기가 고정되어 있을 때, 그리고 데이터 분포가 균등할 때는 잘 동작한다.
하지만 **서버가 추가되거나 기존 서버가 삭제되면 문제가 발생**!

<img width="303" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3 41 28" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/fe825553-798f-48a4-b88f-deaffe10cb8e">

<img width="361" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3 42 17" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/d03a7803-77ee-47cc-9f4e-62963e40a2e3">

서버가 추가되거나 기존 서버가 삭제되면 위 그림 처럼 키에 대한 해시 값은 변하지 않지만 **나머지(%) 연산을 적용하여 계산한 서버의 인덱스 값은 달라진다.**

대부분의 키가 재분배 되었고, 이는 대부분 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하게 된다는 뜻!

그 결과로 **대규모 Cache Miss**가 발생하게 될 것이다.

**안정 해시**로 이 문제를 효과적으로 해결할 수 있다!

## ✨ 안정 해시

**안정 해시(Consistent Hash)**는 해시 테이블 크기가 조정될 때 평균적으로 **오직 k/n개의 키만 재배치**하는 해시 기술이다. (k는 키의 개수, n은 슬롯의 개수)

전통적 해시 테이블은 슬롯의 수가 바귀면 거의 대부분 키를 재배치 한다.

### 📌  해시 공간과 해시 링

- 해시 함수 f로 SHA-1을 사용한다고 가정했을 때, 함수의 해시 공간(Hash Space) 범위는 `0 ~ 2^160 - 1`

<img width="510" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3 57 37" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/fd0737a2-9fef-4fd7-ab22-5d35772b43f6">

<img width="292" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3 57 55" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/74285d3c-8637-4375-9e83-09e7ca45fcbe">
왼쪽은 **해시 공간**을 그림으로 표현한 것이고,
오른쪽은 해시 공간의 양쪽을 구부려서 **해시 링(Hash Ring)**을 만든 것이다.

### 📌 해시 서버

<img width="822" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4 03 29" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/f0150358-1ce1-4174-b175-d49f9a5a53d7">

- 위 그림 처럼 해시 함수 f를 사용하면 서버 IP나 이름을 이 링 위의 어떤 위치에 대응 시킬 수 있다.

### 📌 해시 키

<img width="808" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4 04 42" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/2b77a8c4-f601-46a2-9105-a2e298f73e57">

- 여기서 사용되는 해시 함수는 **연산 %를 사용하지 않았다.**
- 캐시할 키 또한 해시 링 위의 어느 지점에 배치할 수 있다.

### 📌 서버 조회

<img width="828" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4 06 41" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/8b39f156-7d4e-4e57-9863-d8bd43f1f4d2">

- 어떤 키가 저장되는 서버는, 해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫 번째 서버다.

### 📌 서버 추가

<img width="856" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4 12 37" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/d1e74545-4dde-4dc8-b379-d106424274be">


- 서버를 추가하더라도 **키 가운데 일부만 재배치**하면 된다.

### 📌 서버 제거

<img width="800" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4 14 16" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/bbbfd2fa-7f66-43b8-872b-cb0c414da07c">

- 하나의 서버가 제거되면 키 가운데 일부만 재배치 된다.

### 📌 기본 구현 법의 두 가지 문제

**안정 해시 알고리즘의 기본 절차**

- 서버와 키를 균등 분포(Uniform Distribution) 해시 함수를 사용해 해시 링에 배치한다.
- 키의 위치에서 링을 시계 방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버이다.

여기에는 두 가지 문제가 있다.

1. 서버가 추가되거나 삭제되는 상황을 감안하면 **파티션의 크기를 균등하게 유지하는 게 불가능**하다.
여기서 파티션은 인접한 서버 사이의 해시 공간이다.
    
    <img width="806" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4 24 17" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/0c93d126-78a0-48e4-8018-e4e49f5be256">
    
2. **키의 균등 분포를 달성하기가 어렵다.**
아래와 같은 그림일 때 서버 3은 아무 데이터도 갖지 않는 반면, 대부분의 키는 서버 2에 보관될 것이다.
    
    <img width="815" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4 24 40" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/5102342f-68f0-4a94-8066-1a5ccfd99dc9">
    

위와 같은 문제들을 해결하기 위해 가**상 노드(Virtual Node)** 또는 **복제(Replica) 기법**을 사용할 수 있다.

### 📌 가상 노드

**`가상 노드(Virtual Node)`**는 실제 노드 또는 서버를 가리키는 노드로서, **하나의 서버는 링 위에 여러개의 가상 노드를 가질 수 있다.** 따라서 각 서버는 여러 개 파티션을 관리해야 한다.

<img width="825" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4 51 23" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/044d43c1-44a9-4d89-94ae-10c2863f4c7f">

<img width="804" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4 52 37" src="https://github.com/11th-SSAFY-19/large-scale-system-design/assets/71253970/df363a3f-10bc-461f-955f-5fcf4f7a1844">

- 키의 위치로 부터 시계방향으로 링을 탐색하다 만나는 최초의 가상 노드가 해당 키가 저장될 서버가 된다.
- 가상 노드의 개수를 늘리면 표준 편차가 작아져서 데이터가 고르게 분포되기 때문에 키의 분포는 점점 더 균등해진다. (표준 편차: 데이터가 어떻게 퍼져 나갔는지를 보이는 척도)
- 가상 노드의 개수를 더 늘리면 표준 편차의 값은 더 떨어진다. 그러나 가상 노드 데이터를 저장할 공간은 더 많이 필요하게 되므로 tradeoff가 필요하다.

### 📌 안정 해시의 장점

- 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
- 데이터가 보다 균등하게 분포되므로 수평적 규모확장성을 달성하기 쉽다.
- 핫스팟 키 문제를 줄인다. 특정한 샤드에 대한 접근이 지나치게 빈번하면 서버 과부하 문제가 생길 수 있다.

### 📌 안정 해시의 사용 사례

- Amazon DynamoDB의 파티셔닝 관련 컴포넌트
- Apache Cassandra 클러스터에서의 데이터 파티셔닝
- Discord
- Akamai CDN
- Meglev 네트워크 분산기